
import yaml
import glob
import os
from pathlib import Path
from datetime import datetime

# Configuration
REPO_ROOT = Path(__file__).resolve().parent.parent.parent
SKILLS_DIR = REPO_ROOT / "agents/logic/skills"
INDEX_OUTPUT = SKILLS_DIR / "_index.yaml"
TRIGGER_OUTPUT = SKILLS_DIR / "_trigger_engine.yaml"

def load_yaml(path):
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)

def save_yaml(path, data, header=None):
    with open(path, 'w', encoding='utf-8') as f:
        if header:
            f.write(header + "\n")
        yaml.dump(data, f, sort_keys=False, default_flow_style=False, allow_unicode=True)

def compile_registry():
    print(f"Compiling registry from {SKILLS_DIR}...")
    
    meta_files = list(SKILLS_DIR.glob("**/*.meta.yaml"))
    print(f"Found {len(meta_files)} skill definitions.")

    # Data structures for compilation
    index_list = []
    
    # Trigger structures
    extension_rules = {}
    phase_rules = {}
    error_rules = {}
    cluster_definitions = {} # For implicit clusters via .meta.yaml if we support it later
    
    # Track exclusivity conflicts
    reserved_extensions = {} 

    for mf in meta_files:
        try:
            data = load_yaml(mf)
            name = data.get('name')
            if not name:
                print(f"Skipping {mf}: No name field.")
                continue
            
            # 1. Build Index Entry
            index_entry = {
                'name': name,
                'tier': data.get('tier', 'lazy'),
                'cluster': data.get('cluster', 'misc'),
                'priority': data.get('priority', 50),
                'purpose': data.get('purpose', 'No purpose defined')
            }
            index_list.append(index_entry)

            # 2. Extract Triggers (The new "Auto-Register" logic)
            # We look for a 'triggers' section in .meta.yaml
            # Format:
            # triggers:
            #   match_extensions: [.csv, .xlsx]
            #   match_phases: [plan, execute]
            #   match_errors: [FileNotFoundError]
            
            triggers = data.get('triggers', {})
            
            # Extension Triggers
            exts = triggers.get('match_extensions', [])
            for ext in exts:
                if ext not in extension_rules:
                    extension_rules[ext] = {'activate_skills': [], 'suggest_skills': []}
                
                # Decision: In Phase 1, we map everything to 'suggest' unless explicitly 'activate'
                # For now, let's treat all as 'activate' for simplicity or read a flag
                # Better: Check 'tier'. Core -> activate, Lazy -> suggest? 
                # Or just put all in 'suggest' to be safe?
                # Let's check existing logic. most extensions -> activate + suggest.
                
                # SIMPLE STRATEGY: 
                # If tier == 'core' -> activate
                # If tier == 'lazy' -> suggest
                if data.get('tier') == 'core':
                    extension_rules[ext]['activate_skills'].append(name)
                else:
                    extension_rules[ext]['suggest_skills'].append(name)

            # Phase Triggers
            phases = triggers.get('match_phases', [])
            for ph in phases:
                if ph not in phase_rules:
                    phase_rules[ph] = {'activate_skills': [], 'suggest_skills': []}
                
                if data.get('tier') == 'core':
                    phase_rules[ph]['activate_skills'].append(name)
                else:
                    phase_rules[ph]['suggest_skills'].append(name)

            # Error Triggers
            errors = triggers.get('match_errors', [])
            for err in errors:
                if err not in error_rules:
                    error_rules[err] = {'activate_skills': [], 'suggest_skills': []}
                
                if data.get('tier') == 'core':
                    error_rules[err]['activate_skills'].append(name)
                else:
                    error_rules[err]['suggest_skills'].append(name)

        except Exception as e:
            print(f"Error processing {mf}: {e}")

    # Sort index by priority desc
    index_list.sort(key=lambda x: x.get('priority', 0), reverse=True)

    # 3. Write _index.yaml
    index_output_data = {
        'version': '2.0.0',
        'generated_from': 'compile_registry.py',
        'last_updated': datetime.now().strftime("%Y-%m-%d"),
        'index': index_list
    }
    
    header_index = f"# AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.\n# Generated by agents/tools/compile_registry.py at {datetime.now()}"
    save_yaml(INDEX_OUTPUT, index_output_data, header_index)
    print(f"Generated {INDEX_OUTPUT} with {len(index_list)} skills.")

    # 4. Write _trigger_engine.yaml
    # We need to preserve the static parts of trigger engine (Policies, Governance)
    # Strategy: Read a template or just hardcode the static parts for now?
    # Better: Read the EXISTING _trigger_engine.yaml to get the static parts, 
    # then OVERWRITE the dynamic parts.
    
    current_triggers = load_yaml(TRIGGER_OUTPUT)
    
    # Update dynamic sections
    current_triggers['extension_rules'] = extension_rules
    current_triggers['phase_rules'] = phase_rules
    current_triggers['error_rules'] = error_rules
    current_triggers['last_updated'] = datetime.now().strftime("%Y-%m-%d")
    current_triggers['generated_by'] = "compile_registry.py"

    header_triggers = f"# AUTO-GENERATED DYNAMIC SECTIONS. STATIC SECTIONS PRESERVED.\n# Generated by agents/tools/compile_registry.py at {datetime.now()}"
    save_yaml(TRIGGER_OUTPUT, current_triggers, header_triggers)
    print(f"Updated {TRIGGER_OUTPUT} with extracted triggers.")

if __name__ == "__main__":
    compile_registry()

