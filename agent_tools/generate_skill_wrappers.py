#!/usr/bin/env python3
"""
Generate compatibility SKILL.md wrappers from agent/skills/_index.yaml.

Purpose:
- Keep the current framework as source of truth (index + meta + body).
- Expose one wrapper per skill for runtimes that expect <skill>/SKILL.md.

Usage:
    python agent_tools/generate_skill_wrappers.py
    python agent_tools/generate_skill_wrappers.py --dry-run
    python agent_tools/generate_skill_wrappers.py --clean
    python agent_tools/generate_skill_wrappers.py --output-dir agent/skills_wrappers
"""

from __future__ import annotations

import argparse
import shutil
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any

import yaml


SCRIPT_DIR = Path(__file__).resolve().parent
PROJECT_ROOT = SCRIPT_DIR.parent
SKILLS_DIR = PROJECT_ROOT / "agent" / "skills"
INDEX_PATH = SKILLS_DIR / "_index.yaml"
DEFAULT_OUTPUT_DIR = PROJECT_ROOT / "agent" / "skills_wrappers"


@dataclass
class SkillRef:
    name: str
    tier: str
    cluster: str
    priority: Any
    purpose: str
    body_path: Path | None
    meta_path: Path | None


def load_yaml(path: Path) -> Any:
    with path.open("r", encoding="utf-8") as f:
        return yaml.safe_load(f)


def load_index(index_path: Path) -> list[dict[str, Any]]:
    data = load_yaml(index_path)
    if not isinstance(data, dict):
        return []
    index = data.get("index", [])
    return index if isinstance(index, list) else []


def find_body_file(skills_dir: Path, skill_name: str) -> Path | None:
    matches = [p for p in skills_dir.rglob(f"{skill_name}.md") if p.name != "README.md"]
    if not matches:
        return None
    # Prefer shortest relative path if multiple candidates exist.
    matches.sort(key=lambda p: len(str(p.relative_to(skills_dir))))
    return matches[0]


def find_meta_file(skills_dir: Path, skill_name: str) -> Path | None:
    matches = list(skills_dir.rglob(f"{skill_name}.meta.yaml"))
    if not matches:
        return None
    matches.sort(key=lambda p: len(str(p.relative_to(skills_dir))))
    return matches[0]


def to_repo_rel(path: Path | None) -> str:
    if path is None:
        return "(not found)"
    return path.relative_to(PROJECT_ROOT).as_posix()


def build_skill_refs(skills_dir: Path, entries: list[dict[str, Any]]) -> list[SkillRef]:
    refs: list[SkillRef] = []
    for item in entries:
        if not isinstance(item, dict):
            continue
        name = str(item.get("name", "")).strip()
        if not name:
            continue
        refs.append(
            SkillRef(
                name=name,
                tier=str(item.get("tier", "unknown")),
                cluster=str(item.get("cluster", "unknown")),
                priority=item.get("pri", item.get("priority", "unknown")),
                purpose=str(item.get("purpose", "")),
                body_path=find_body_file(skills_dir, name),
                meta_path=find_meta_file(skills_dir, name),
            )
        )
    return refs


def render_wrapper(skill: SkillRef) -> str:
    body = to_repo_rel(skill.body_path)
    meta = to_repo_rel(skill.meta_path)
    return f"""# SKILL.md - {skill.name}

This is an auto-generated compatibility wrapper.
Source of truth remains in the Invoker framework paths listed below.

## Skill Identity
- Name: `{skill.name}`
- Tier: `{skill.tier}`
- Cluster: `{skill.cluster}`
- Priority: `{skill.priority}`
- Purpose: {skill.purpose or "(no purpose in index)"}

## Source Files
- Body (Layer 3): `{body}`
- Metadata (Layer 2): `{meta}`
- Index (Layer 1): `agent/skills/_index.yaml`
- Trigger rules: `agent/skills/_trigger_engine.yaml`

## Execution Contract
1. Use this wrapper only as an entry point for compatibility.
2. Load Layer 2 and Layer 3 from the source files above.
3. Do not treat this wrapper as authoritative if source files disagree.
4. If source files are missing, report and continue with best-effort fallback.

## Maintenance
- Generated by: `agent_tools/generate_skill_wrappers.py`
- Generated deterministically from: `agent/skills/_index.yaml`
- Do not edit manually. Regenerate instead.
"""


def write_wrappers(skills: list[SkillRef], output_dir: Path, dry_run: bool) -> tuple[int, int]:
    created = 0
    updated = 0
    for skill in skills:
        skill_dir = output_dir / skill.name
        file_path = skill_dir / "SKILL.md"
        content = render_wrapper(skill)

        if dry_run:
            exists = file_path.exists()
            if not exists:
                created += 1
            else:
                current = file_path.read_text(encoding="utf-8")
                if current != content:
                    updated += 1
            continue

        skill_dir.mkdir(parents=True, exist_ok=True)
        if not file_path.exists():
            created += 1
            file_path.write_text(content, encoding="utf-8")
            continue

        current = file_path.read_text(encoding="utf-8")
        if current != content:
            updated += 1
            file_path.write_text(content, encoding="utf-8")
    return created, updated


def clean_stale_dirs(output_dir: Path, keep_skill_names: set[str], dry_run: bool) -> int:
    if not output_dir.exists():
        return 0
    removed = 0
    for child in output_dir.iterdir():
        if not child.is_dir():
            continue
        if child.name in keep_skill_names:
            continue
        removed += 1
        if not dry_run:
            shutil.rmtree(child)
    return removed


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate compatibility SKILL.md wrappers")
    parser.add_argument("--index-path", type=Path, default=INDEX_PATH, help="Path to _index.yaml")
    parser.add_argument("--skills-dir", type=Path, default=SKILLS_DIR, help="Path to skills directory")
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=DEFAULT_OUTPUT_DIR,
        help="Wrapper output directory",
    )
    parser.add_argument("--dry-run", action="store_true", help="Show actions without writing files")
    parser.add_argument("--clean", action="store_true", help="Remove stale wrapper directories")
    args = parser.parse_args()

    index_path = args.index_path.resolve()
    skills_dir = args.skills_dir.resolve()
    output_dir = args.output_dir.resolve()

    if not index_path.exists():
        print(f"[ERROR] Missing index: {index_path}")
        return 1
    if not skills_dir.exists():
        print(f"[ERROR] Missing skills directory: {skills_dir}")
        return 1

    entries = load_index(index_path)
    if not entries:
        print(f"[ERROR] No skills found in index: {index_path}")
        return 1

    skills = build_skill_refs(skills_dir, entries)
    keep_names = {s.name for s in skills}

    if not args.dry_run:
        output_dir.mkdir(parents=True, exist_ok=True)

    created, updated = write_wrappers(skills, output_dir, args.dry_run)
    missing_bodies = sum(1 for s in skills if s.body_path is None)
    missing_meta = sum(1 for s in skills if s.meta_path is None)
    removed = clean_stale_dirs(output_dir, keep_names, args.dry_run) if args.clean else 0

    mode = "DRY RUN" if args.dry_run else "WRITE"
    print("=" * 60)
    print(f"WRAPPER GENERATION ({mode})")
    print("=" * 60)
    print(f"Index entries:         {len(entries)}")
    print(f"Wrappers created:      {created}")
    print(f"Wrappers updated:      {updated}")
    print(f"Skills missing body:   {missing_bodies}")
    print(f"Skills missing meta:   {missing_meta}")
    if args.clean:
        print(f"Stale wrapper dirs:    {removed}")
    print(f"Output directory:      {output_dir}")
    print("=" * 60)

    return 0


if __name__ == "__main__":
    sys.exit(main())
