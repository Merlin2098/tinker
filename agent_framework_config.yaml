# agent_framework_config.yaml
#
# Central configuration for the Tinker agent framework.
# This file governs how the framework integrates with any HOST PROJECT
# it is deployed into.
#
# PORTABLE DEPLOYMENT MODEL:
# The framework (agent/, agent_tools/, this file) is designed to be
# copied into any Python project.  The host project's .gitignore should
# exclude the framework's directories so that:
#   1. The framework's own files don't pollute the host project's git history.
#   2. treemap.py and analyze_dependencies.py scan the HOST project — not the
#      framework — because they respect .gitignore from the project root.
#   3. Generated analysis files (treemap.md, dependencies_report.md) live
#      inside the gitignored agent/ directory and are loaded on-demand only.

# ============================================================================
# Deployment layout
# ============================================================================
deployment:
  # Directories and files that constitute "the framework".
  # The host project's .gitignore MUST include these entries.
  framework_footprint:
    - agent/
    - agent_tools/
    - .clinerules
    - agent_framework_config.yaml
    - instructions/claude/
    - instructions/chat/
    - instructions/model_agnostic/

  # Recommended lines to add to the HOST project's .gitignore.
  # A ready-to-copy template is available in .gitignore.host
  host_gitignore_entries:
    - "# Tinker agent framework (portable — not part of host project)"
    - "agent/"
    - "agent_tools/"
    - ".clinerules"
    - "agent_framework_config.yaml"
    - "instructions/claude/"
    - "instructions/chat/"
    - "instructions/model_agnostic/"

  # How the project root is resolved at runtime.
  # All agent_tools scripts use: parent(parent(__file__)) → host project root.
  # This means the framework MUST live one level deep inside the host project.
  project_root_strategy: parent_of_agent_tools

# Optional default static context profile.
# Resolution order at runtime:
#   1) CLI arg --profile
#   2) TINKER_CONTEXT_PROFILE env var
#   3) active_profile (this field)
#   4) profile_detection rules
#   5) default static_context
active_profile: null

# Optional automatic environment detection for profile activation.
# If enabled, this is used when no explicit profile is provided via
# --profile, TINKER_CONTEXT_PROFILE, or active_profile.
profile_detection:
  enabled: true
  fallback_profile: default
  rules:
    - profile: interactive_terminal
      match: any
      env_exists:
        - TERM_PROGRAM
        - SSH_TTY
    - profile: constrained_terminal
      match: any
      env_exists:
        - CI
        - GITHUB_ACTIONS

# ============================================================================
# Static context (context.json)
# ============================================================================
# Generated by load_static_context.py during Step 1 of initialization.
# Describes the HOST project structure — the framework itself is excluded
# because it is gitignored.
static_context:
  output_path: agent/agent_outputs/context.json

  # Governance: context.json must stay under this limit.
  max_lines: 1000

  # File tree depth for the host project overview.
  file_tree_max_depth: 2

  # Python AST signature extraction depth.
  python_signatures_max_depth: 3

  # Truncation policy for hard line-budget enforcement.
  # Applied only when generated context exceeds max_lines.
  truncation_policy:
    # Deterministic reducer order.
    reducer_order:
      - trim_python_signatures
      - trim_file_tree
      - trim_schema_summaries
      - trim_agent_rules_sections
      - drop_python_signatures
      - drop_schema_summaries
      - drop_agent_rules_sections
      - drop_file_tree_to_minimum

    # Percentage of entries removed on each trim step.
    trim_fraction_percent: 10

    # Floors used by trim/drop reducers.
    minimum_file_tree_entries: 0
    minimum_agent_rules_sections: 0
    minimum_schema_top_level_keys: 3

  # Directories excluded from the file tree BEYOND what .gitignore covers.
  # These are framework-internal directories that would remain visible if the
  # host project uses granular gitignore rules instead of blanket "agent/".
  excluded_dirs_from_tree:
    - agent/skills
    - agent/agent_outputs
    - agent/agent_logs

  # Directories excluded from Python signature extraction.
  excluded_from_signatures:
    - agent/skills

  # Hard-coded directory exclusions (always skipped, every OS).
  always_excluded_dirs:
    - .git
    - __pycache__
    - node_modules
    - .venv
    - venv

# Optional runtime-specific overrides.
# Each profile merges over static_context.
static_context_profiles:
  constrained_terminal:
    max_lines: 700
    file_tree_max_depth: 2
    python_signatures_max_depth: 2
    truncation_policy:
      trim_fraction_percent: 15
  interactive_terminal:
    max_lines: 1200
    file_tree_max_depth: 3
    python_signatures_max_depth: 4
    truncation_policy:
      trim_fraction_percent: 8

# ============================================================================
# On-demand file loading
# ============================================================================
# These files are generated INSIDE the gitignored agent/ directory.
# They describe the HOST project (not the framework).
# They are NOT included in the initial context.json — agents request them
# explicitly via context_loader.load_on_demand(<name>).
#
# Why on-demand?
#   - treemap.md can be large (500+ lines for big projects).
#   - dependencies_report.md grows with the number of Python modules.
#   - Including them in context.json would break the 1,000-line governance limit.
#   - They are only needed during structural/dependency analysis tasks.
on_demand_files:
  treemap:
    path: agent/analysis/treemap.md
    description: >
      Full recursive file tree of the HOST project.
      Generated by agent_tools/treemap.py, respects host .gitignore.
    format: markdown
    generated_by: agent_tools/treemap.py

  dependencies_report:
    path: agent/analysis/dependencies_report.md
    description: >
      Python module dependency graph of the HOST project.
      Generated by agent_tools/analyze_dependencies.py, respects host .gitignore.
    format: markdown
    generated_by: agent_tools/analyze_dependencies.py

# ============================================================================
# Gitignore compliance
# ============================================================================
gitignore:
  # The static context generator and analysis tools MUST respect the host
  # project's .gitignore.  This ensures the framework's own files are
  # invisible to the context — only the host project's code is analyzed.
  respect_gitignore: true

  # When the pathspec library is not installed, the framework falls back to
  # the always_excluded_dirs list above.  This is a degraded mode — install
  # pathspec for full compliance.
  fallback_warning: >
    pathspec library not found.  Only hard-coded exclusions will be applied.
    Run: pip install pathspec

# ============================================================================
# Data path governance (pipeline runtime)
# ============================================================================
# This section formalizes environment-aware data path policy:
# - dev/test: local data directories are allowed for debugging.
# - prod: data roots must live outside project_root.
# - source and output must be separated to preserve unidirectional flow.
data_governance:
  enabled: true

  environments:
    dev:
      allow_project_local_data_root: true
      debug_data_allowed: true
    test:
      allow_project_local_data_root: true
      debug_data_allowed: true
    prod:
      allow_project_local_data_root: false
      debug_data_allowed: false
      require_external_data_root: true

  # Default local testing layout (used when env vars are not provided).
  # In production, DATA_ROOT must be explicit and external.
  default_data_root: data
  default_source_subdir: source
  default_output_subdir: output

  # Unidirectional pipeline guard.
  require_source_output_separation: true

  # If true, output/report generation must consume previously materialized
  # artifacts from disk, not in-memory intermediates.
  require_final_layer_from_materialized_inputs: true

  # Output format is use-case dependent. Do not enforce parquet globally.
  # Plans/pipelines must declare format per output artifact.
  required_output_format_policy: per_use_case_declared

